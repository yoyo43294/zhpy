## 物件導向 ##

以 wkipedia [物件導向](http://zh.wikipedia.org/wiki/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91) 範例中的虛擬碼為例，改寫成周蟒版本。

### 類別 ###

類別（Class）定義了一件事物的抽象特點。通常來說，類別定義了事物的屬性和它可以做到的（它的行為）。舉例來說，「狗」這個類別會包含狗的一切基礎特徵，例如它的孕育、毛皮顏色和吠叫的能力。類別可以為程式提供模版和結構。

```
類別 狗

    定義 __初始化__(我):
        我.毛皮顏色 = ""
        我.孕育 = ""

    定義 吠叫(我)
        略過
```

### 物件 ###

物件（Object）是類別的實例。例如，「狗」這個類別列舉狗的特點，從而使這個類別定義了世界上所有的狗。而萊絲這個物件則是一條具體的狗，它的屬性也是具體的。狗有皮毛顏色，而萊絲的皮毛顏色是棕白色的。因此，萊絲就是狗這個類別的一個實例。

假設我們已經在上面定義了狗這個類別，我們就可以用這個類別來定義物件：

```
萊絲 = 狗()
萊絲.毛皮顏色 = '棕白色'
萊絲.吠叫()
```


### 方法 ###

方法（Method）是一個類別能做的事情，但方法並沒有去做這件事。
對一個具體物件的方法進行調用並不影響其它物件，正如所有的狗都會叫，但是你讓一條狗叫不代表所有的狗都叫。

```
萊絲 = 狗()
泰爾 = 狗()
萊絲.吠叫()
```

### 繼承性 ###

繼承性（Inheritance）是指，在某種情況下，一個類別會有「子類別」。子類別比原本的類別（稱為父類別）要更加具體化，例如，「狗」這個類別可能會有它的子類別「牧羊犬」和「吉娃娃犬」。在這種情況下，「萊絲」可能就是牧羊犬的一個實例。子類別會繼承父類別的屬性和行為，並且也可包含它們自己的。我們假設「狗」這個類別有一個方法叫做「吠叫()」和一個屬性叫做「毛皮顏色」。它的子類別（前例中的牧羊犬和吉娃娃犬）會繼承這些成員。這意味著程式設計師只需要將相同的代碼寫一次。

```
類別 牧羊犬(狗):
    略過

萊絲 = 牧羊犬()
萊絲.吠叫() # 注意這裡調用的是狗這個類別的吠叫屬性。
```

子類別也可以加入新的成員，例如，「吉娃娃犬」這個類別可以加入一個方法叫做「顫抖()」。設若用「牧羊犬」這個類別定義了一個實例「萊絲」，那麼萊絲就不會顫抖，因為這個方法是屬於吉娃娃犬的，而非牧羊犬。


```
類別 吉娃娃犬(狗):
    定義 顫抖(我)
        略過

類別 牧羊犬(狗):
    略過

萊絲 = 牧羊犬()
萊絲.顫抖()    # 錯誤：顫抖是吉娃娃犬的成員方法。
```

### 封裝性 ###

具備封裝性（Encapsulation）的物件導向程式設計隱藏了某一方法的具體執行步驟，取而代之的是通過消息傳遞機制傳送消息給它。因此，舉例來說，「狗」這個類別有」吠叫()」的方法，這一方法定義了狗具體該通過什麼方法吠叫。但是，萊絲的朋友蒂米並不需要知道它到底如何吠叫。

```
# 一個流程導向的程式會這樣寫：
定義 萊絲吠叫()
    設置音調(5)
    吸氣()
    吐氣()

# 而當狗的吠叫被封裝到類別中，任何人都可以簡單地使用：
萊絲 = 狗()
萊絲.吠叫()

```

### 多態性 ###

多態性（Polymorphism）指方法在不同的類別中調用可以實現的不同結果。因此，2個甚至更多的類別可以對同一消息作出不同的反應。舉例來說，狗和雞都有「叫()」這一方法，但是調用狗的「叫()」，[[狗]]會吠叫；調用[[雞]]的「叫()」，雞則會啼叫。

```
類別 狗:
    定義 叫()
        吠叫()

類別 雞:
    定義 叫()
        啼叫()

萊絲 = 狗()
魯斯特 = 雞()
萊絲.叫()
魯斯特.叫()
```

這樣，同樣是叫，萊絲和魯斯特做出的反應將大不相同。